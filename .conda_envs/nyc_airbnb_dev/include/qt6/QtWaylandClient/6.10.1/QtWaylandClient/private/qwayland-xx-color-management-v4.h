// This file was generated by qtwaylandscanner
// source file is xx-color-management-v4.xml

#ifndef QT_WAYLAND_XX_COLOR_MANAGEMENT_V4
#define QT_WAYLAND_XX_COLOR_MANAGEMENT_V4

#include <QtWaylandClient/private/wayland-xx-color-management-v4-client-protocol.h>
#include <QByteArray>
#include <QString>

struct wl_registry;

QT_BEGIN_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
QT_WARNING_DISABLE_CLANG("-Wmissing-field-initializers")
#if !defined(Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT)
#  if defined(QT_SHARED) && !defined(QT_STATIC)
#    if defined(QT_BUILD_WAYLANDCLIENT_LIB)
#      define Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT Q_DECL_EXPORT
#    else
#      define Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT Q_DECL_IMPORT
#    endif
#  else
#    define Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT
#  endif
#endif

namespace QtWayland {
    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_color_manager_v4
    {
    public:
        xx_color_manager_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_color_manager_v4(struct ::xx_color_manager_v4 *object);
        xx_color_manager_v4();

        virtual ~xx_color_manager_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_color_manager_v4 *object);

        struct ::xx_color_manager_v4 *object() { return m_xx_color_manager_v4; }
        const struct ::xx_color_manager_v4 *object() const { return m_xx_color_manager_v4; }
        static xx_color_manager_v4 *fromObject(struct ::xx_color_manager_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_unsupported_feature = 0, // request not supported
            error_surface_exists = 1, // color management surface exists already
        };

        enum render_intent {
            render_intent_perceptual = 0, // perceptual
            render_intent_relative = 1, // media-relative colorimetric
            render_intent_saturation = 2, // saturation
            render_intent_absolute = 3, // ICC-absolute colorimetric
            render_intent_relative_bpc = 4, // media-relative colorimetric + black point compensation
        };

        enum feature {
            feature_icc_v2_v4 = 0, // new_icc_creator request
            feature_parametric = 1, // new_parametric_creator request
            feature_set_primaries = 2, // parametric set_primaries request
            feature_set_tf_power = 3, // parametric set_tf_power request
            feature_set_luminances = 4, // parametric set_luminances request
            feature_set_mastering_display_primaries = 5,
            feature_extended_target_volume = 6,
        };

        enum primaries {
            primaries_srgb = 0,
            primaries_pal_m = 1,
            primaries_pal = 2,
            primaries_ntsc = 3,
            primaries_generic_film = 4,
            primaries_bt2020 = 5,
            primaries_cie1931_xyz = 6,
            primaries_dci_p3 = 7,
            primaries_display_p3 = 8,
            primaries_adobe_rgb = 9,
        };

        enum transfer_function {
            transfer_function_bt709 = 0,
            transfer_function_gamma22 = 1,
            transfer_function_gamma28 = 2,
            transfer_function_st240 = 3,
            transfer_function_linear = 4,
            transfer_function_log_100 = 5,
            transfer_function_log_316 = 6,
            transfer_function_xvycc = 7,
            transfer_function_bt1361 = 8,
            transfer_function_srgb = 9,
            transfer_function_ext_srgb = 10,
            transfer_function_st2084_pq = 11,
            transfer_function_st428 = 12,
            transfer_function_hlg = 13,
        };

        void destroy();
        struct ::xx_color_management_output_v4 *get_output(struct ::wl_output *output);
        struct ::xx_color_management_surface_v4 *get_surface(struct ::wl_surface *surface);
        struct ::xx_color_management_feedback_surface_v4 *get_feedback_surface(struct ::wl_surface *surface);
        struct ::xx_image_description_creator_icc_v4 *new_icc_creator();
        struct ::xx_image_description_creator_params_v4 *new_parametric_creator();

    protected:
        virtual void xx_color_manager_v4_supported_intent(uint32_t render_intent);
        virtual void xx_color_manager_v4_supported_feature(uint32_t feature);
        virtual void xx_color_manager_v4_supported_tf_named(uint32_t tf);
        virtual void xx_color_manager_v4_supported_primaries_named(uint32_t primaries);

    private:
        void init_listener();
        static const struct xx_color_manager_v4_listener m_xx_color_manager_v4_listener;
        static void handle_supported_intent(
            void *data,
            struct ::xx_color_manager_v4 *object,
            uint32_t render_intent);
        static void handle_supported_feature(
            void *data,
            struct ::xx_color_manager_v4 *object,
            uint32_t feature);
        static void handle_supported_tf_named(
            void *data,
            struct ::xx_color_manager_v4 *object,
            uint32_t tf);
        static void handle_supported_primaries_named(
            void *data,
            struct ::xx_color_manager_v4 *object,
            uint32_t primaries);
        struct ::xx_color_manager_v4 *m_xx_color_manager_v4;
    };

    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_color_management_output_v4
    {
    public:
        xx_color_management_output_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_color_management_output_v4(struct ::xx_color_management_output_v4 *object);
        xx_color_management_output_v4();

        virtual ~xx_color_management_output_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_color_management_output_v4 *object);

        struct ::xx_color_management_output_v4 *object() { return m_xx_color_management_output_v4; }
        const struct ::xx_color_management_output_v4 *object() const { return m_xx_color_management_output_v4; }
        static xx_color_management_output_v4 *fromObject(struct ::xx_color_management_output_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        void destroy();
        struct ::xx_image_description_v4 *get_image_description();

    protected:
        virtual void xx_color_management_output_v4_image_description_changed();

    private:
        void init_listener();
        static const struct xx_color_management_output_v4_listener m_xx_color_management_output_v4_listener;
        static void handle_image_description_changed(
            void *data,
            struct ::xx_color_management_output_v4 *object);
        struct ::xx_color_management_output_v4 *m_xx_color_management_output_v4;
    };

    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_color_management_surface_v4
    {
    public:
        xx_color_management_surface_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_color_management_surface_v4(struct ::xx_color_management_surface_v4 *object);
        xx_color_management_surface_v4();

        virtual ~xx_color_management_surface_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_color_management_surface_v4 *object);

        struct ::xx_color_management_surface_v4 *object() { return m_xx_color_management_surface_v4; }
        const struct ::xx_color_management_surface_v4 *object() const { return m_xx_color_management_surface_v4; }
        static xx_color_management_surface_v4 *fromObject(struct ::xx_color_management_surface_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_render_intent = 0, // unsupported rendering intent
            error_image_description = 1, // invalid image description
        };

        void destroy();
        void set_image_description(struct ::xx_image_description_v4 *image_description, uint32_t render_intent);
        void unset_image_description();

    private:
        struct ::xx_color_management_surface_v4 *m_xx_color_management_surface_v4;
    };

    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_color_management_feedback_surface_v4
    {
    public:
        xx_color_management_feedback_surface_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_color_management_feedback_surface_v4(struct ::xx_color_management_feedback_surface_v4 *object);
        xx_color_management_feedback_surface_v4();

        virtual ~xx_color_management_feedback_surface_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_color_management_feedback_surface_v4 *object);

        struct ::xx_color_management_feedback_surface_v4 *object() { return m_xx_color_management_feedback_surface_v4; }
        const struct ::xx_color_management_feedback_surface_v4 *object() const { return m_xx_color_management_feedback_surface_v4; }
        static xx_color_management_feedback_surface_v4 *fromObject(struct ::xx_color_management_feedback_surface_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_inert = 0, // forbidden request on inert object
        };

        void destroy();
        struct ::xx_image_description_v4 *get_preferred();

    protected:
        virtual void xx_color_management_feedback_surface_v4_preferred_changed();

    private:
        void init_listener();
        static const struct xx_color_management_feedback_surface_v4_listener m_xx_color_management_feedback_surface_v4_listener;
        static void handle_preferred_changed(
            void *data,
            struct ::xx_color_management_feedback_surface_v4 *object);
        struct ::xx_color_management_feedback_surface_v4 *m_xx_color_management_feedback_surface_v4;
    };

    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_image_description_creator_icc_v4
    {
    public:
        xx_image_description_creator_icc_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_image_description_creator_icc_v4(struct ::xx_image_description_creator_icc_v4 *object);
        xx_image_description_creator_icc_v4();

        virtual ~xx_image_description_creator_icc_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_image_description_creator_icc_v4 *object);

        struct ::xx_image_description_creator_icc_v4 *object() { return m_xx_image_description_creator_icc_v4; }
        const struct ::xx_image_description_creator_icc_v4 *object() const { return m_xx_image_description_creator_icc_v4; }
        static xx_image_description_creator_icc_v4 *fromObject(struct ::xx_image_description_creator_icc_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_incomplete_set = 0, // incomplete parameter set
            error_already_set = 1, // property already set
            error_bad_fd = 2, // fd not seekable and readable
            error_bad_size = 3, // no or too much data
            error_out_of_file = 4, // offset + length exceeds file size
        };

        struct ::xx_image_description_v4 *create();
        void set_icc_file(int32_t icc_profile, uint32_t offset, uint32_t length);

    private:
        struct ::xx_image_description_creator_icc_v4 *m_xx_image_description_creator_icc_v4;
    };

    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_image_description_creator_params_v4
    {
    public:
        xx_image_description_creator_params_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_image_description_creator_params_v4(struct ::xx_image_description_creator_params_v4 *object);
        xx_image_description_creator_params_v4();

        virtual ~xx_image_description_creator_params_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_image_description_creator_params_v4 *object);

        struct ::xx_image_description_creator_params_v4 *object() { return m_xx_image_description_creator_params_v4; }
        const struct ::xx_image_description_creator_params_v4 *object() const { return m_xx_image_description_creator_params_v4; }
        static xx_image_description_creator_params_v4 *fromObject(struct ::xx_image_description_creator_params_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_incomplete_set = 0, // incomplete parameter set
            error_inconsistent_set = 1, // invalid combination of parameters
            error_already_set = 2, // property already set
            error_unsupported_feature = 3, // request not supported
            error_invalid_tf = 4, // invalid transfer characteristic
            error_invalid_primaries = 5, // invalid primaries or white point
            error_invalid_luminance = 6, // invalid luminance value or range
            error_invalid_mastering = 7, // invalid mastering information
        };

        struct ::xx_image_description_v4 *create();
        void set_tf_named(uint32_t tf);
        void set_tf_power(uint32_t eexp);
        void set_primaries_named(uint32_t primaries);
        void set_primaries(int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x, int32_t b_y, int32_t w_x, int32_t w_y);
        void set_luminances(uint32_t min_lum, uint32_t max_lum, uint32_t reference_lum);
        void set_mastering_display_primaries(int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x, int32_t b_y, int32_t w_x, int32_t w_y);
        void set_mastering_luminance(uint32_t min_lum, uint32_t max_lum);
        void set_max_cll(uint32_t max_cll);
        void set_max_fall(uint32_t max_fall);

    private:
        struct ::xx_image_description_creator_params_v4 *m_xx_image_description_creator_params_v4;
    };

    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_image_description_v4
    {
    public:
        xx_image_description_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_image_description_v4(struct ::xx_image_description_v4 *object);
        xx_image_description_v4();

        virtual ~xx_image_description_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_image_description_v4 *object);

        struct ::xx_image_description_v4 *object() { return m_xx_image_description_v4; }
        const struct ::xx_image_description_v4 *object() const { return m_xx_image_description_v4; }
        static xx_image_description_v4 *fromObject(struct ::xx_image_description_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

        enum error {
            error_not_ready = 0, // attempted to use an object which is not ready
            error_no_information = 1, // get_information not allowed
        };

        enum cause {
            cause_low_version = 0, // interface version too low
            cause_unsupported = 1, // unsupported image description data
            cause_operating_system = 2, // error independent of the client
            cause_no_output = 3, // the relevant output no longer exists
        };

        void destroy();
        struct ::xx_image_description_info_v4 *get_information();

    protected:
        virtual void xx_image_description_v4_failed(uint32_t cause, const QString &msg);
        virtual void xx_image_description_v4_ready(uint32_t identity);

    private:
        void init_listener();
        static const struct xx_image_description_v4_listener m_xx_image_description_v4_listener;
        static void handle_failed(
            void *data,
            struct ::xx_image_description_v4 *object,
            uint32_t cause,
            const char *msg);
        static void handle_ready(
            void *data,
            struct ::xx_image_description_v4 *object,
            uint32_t identity);
        struct ::xx_image_description_v4 *m_xx_image_description_v4;
    };

    class Q_WAYLAND_CLIENT_XX_COLOR_MANAGEMENT_V4_EXPORT xx_image_description_info_v4
    {
    public:
        xx_image_description_info_v4(struct ::wl_registry *registry, uint32_t id, int version);
        xx_image_description_info_v4(struct ::xx_image_description_info_v4 *object);
        xx_image_description_info_v4();

        virtual ~xx_image_description_info_v4();

        void init(struct ::wl_registry *registry, uint32_t id, int version);
        void init(struct ::xx_image_description_info_v4 *object);

        struct ::xx_image_description_info_v4 *object() { return m_xx_image_description_info_v4; }
        const struct ::xx_image_description_info_v4 *object() const { return m_xx_image_description_info_v4; }
        static xx_image_description_info_v4 *fromObject(struct ::xx_image_description_info_v4 *object);

        bool isInitialized() const;

        uint32_t version() const;
        static const struct ::wl_interface *interface();

    protected:
        virtual void xx_image_description_info_v4_done();
        virtual void xx_image_description_info_v4_icc_file(int32_t icc, uint32_t icc_size);
        virtual void xx_image_description_info_v4_primaries(int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x, int32_t b_y, int32_t w_x, int32_t w_y);
        virtual void xx_image_description_info_v4_primaries_named(uint32_t primaries);
        virtual void xx_image_description_info_v4_tf_power(uint32_t eexp);
        virtual void xx_image_description_info_v4_tf_named(uint32_t tf);
        virtual void xx_image_description_info_v4_luminances(uint32_t min_lum, uint32_t max_lum, uint32_t reference_lum);
        virtual void xx_image_description_info_v4_target_primaries(int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x, int32_t b_y, int32_t w_x, int32_t w_y);
        virtual void xx_image_description_info_v4_target_luminance(uint32_t min_lum, uint32_t max_lum);
        virtual void xx_image_description_info_v4_target_max_cll(uint32_t max_cll);
        virtual void xx_image_description_info_v4_target_max_fall(uint32_t max_fall);

    private:
        void init_listener();
        static const struct xx_image_description_info_v4_listener m_xx_image_description_info_v4_listener;
        static void handle_done(
            void *data,
            struct ::xx_image_description_info_v4 *object);
        static void handle_icc_file(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            int32_t icc,
            uint32_t icc_size);
        static void handle_primaries(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            int32_t r_x,
            int32_t r_y,
            int32_t g_x,
            int32_t g_y,
            int32_t b_x,
            int32_t b_y,
            int32_t w_x,
            int32_t w_y);
        static void handle_primaries_named(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            uint32_t primaries);
        static void handle_tf_power(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            uint32_t eexp);
        static void handle_tf_named(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            uint32_t tf);
        static void handle_luminances(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            uint32_t min_lum,
            uint32_t max_lum,
            uint32_t reference_lum);
        static void handle_target_primaries(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            int32_t r_x,
            int32_t r_y,
            int32_t g_x,
            int32_t g_y,
            int32_t b_x,
            int32_t b_y,
            int32_t w_x,
            int32_t w_y);
        static void handle_target_luminance(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            uint32_t min_lum,
            uint32_t max_lum);
        static void handle_target_max_cll(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            uint32_t max_cll);
        static void handle_target_max_fall(
            void *data,
            struct ::xx_image_description_info_v4 *object,
            uint32_t max_fall);
        struct ::xx_image_description_info_v4 *m_xx_image_description_info_v4;
    };
}

QT_WARNING_POP
QT_END_NAMESPACE

#endif
